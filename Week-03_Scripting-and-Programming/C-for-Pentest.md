# C Language Essentials for Pentesters  

> **Focus:** mastering low‑level C fundamentals so you can move from Bash scripts to fast native tooling (scanners, resolvers, DoS helpers) during penetration tests.

---

## Table of Contents
1. [Creating & Compiling Your First Program](#1-creating--compiling-your-first-program)
2. [Working with Variables](#2-working-with-variables)
3. [Taking User Input Safely](#3-taking-user-input-safely)
4. [Executing System Commands](#4-executing-system-commands)
5. [Using Arguments & Loops](#5-using-arguments--loops)
6. [Understanding the Compilation Process](#6-understanding-the-compilation-process)
7. [Writing a Simple DNS Resolver](#7-writing-a-simple-dns-resolver)
8. [Working with Sockets](#8-working-with-sockets)
9. [Building a Basic TCP Port Scanner](#9-building-a-basic-tcp-port-scanner)

---

## 1 – Creating & Compiling Your First Program
```bash
# create file
nano program.c
```
```c
// My first C program
int main() {
    return 0;
}
```
Compile & link in one shot:
```bash
gcc program.c -o program
```
`gcc` warns that `main` should return an `int`; adding `int` and a `return 0;` satisfies the C standard.  
The resulting **ELF** binary (`program`) sits next to your source file (`program.c`).

---

## 2 – Working with Variables
```c
#include <stdio.h>

// Simple network scan banner
int main(void) {
    int   port   = 80;            // 32‑bit signed integer
    char  ip[]   = "192.168.0.1"; // char array = C‑style string
    float ver    = 1.1;           // 32‑bit floating point

    printf("Desec Security\n");
    printf("Scan version: %.1f\n", ver);      // string + float
    printf("Scanning host %s on port %d\n",   // %s + %d concatenate
           ip, port);                          // at runtime
    return 0;
}
```
**Why it matters**

| Keyword | Size | Typical Use |
|---------|------|-------------|
| `char`  | 1 B  | single byte / character |
| `int`   | 4 B  | whole numbers / counters |
| `float` | 4 B  | quick decimals (≈ 7 digits precision) |

`printf` is *type‑aware*: format specifiers (`%s`, `%d`, `%.1f`) let you “concatenate” different variable types into a single output string without unsafe manual copying.

---

## 3 – Taking User Input Safely
`scanf` reads raw bytes and **doesn’t** cap length—easy buffer‑overflow fodder.

### Vulnerable approach (avoid in new code)
```c
scanf("%s", ip);   // No length limit!
```

### Safer approach with `fgets` + `sscanf`
```c
#include <stdio.h>

int main(void) {
    int  port;
    char ip[16];               // 15 chars + NULL

    printf("Desec Security\n");

    printf("Enter IP: ");
    if (fgets(ip, sizeof ip, stdin) == NULL) return 1;

    printf("Enter port: ");
    if (scanf("%d", &port) != 1) return 1;

    printf("Scanning host %s on port %d\n", ip, port);
    return 0;
}
```
`fgets` respects the buffer size, then you can parse with `sscanf` or trim the trailing newline.

---

## 4 – Executing System Commands
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    puts("Open TCP ports:");
    system("netstat -nlpt");   // Spawn shell, run command
    return 0;
}
```
Ideal for quick PoCs; for production, prefer native APIs (`/proc`, `libpcap`, etc.).

---

## 5 – Using Arguments & Loops
```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: %s <base‑ip> <port>\n", argv[0]);
        return 1;
    }

    for (int i = 0; i <= 10; i++) {
        printf("Scanning host %s.%d on port %s\n",
               argv[1], i, argv[2]);
    }
    return 0;
}
```
- `argc` = argument count  
- `argv[]` = argument vector (strings)  
Use loops (`for`, `while`) to automate repetitive scans.

---

## 6 – Understanding the Compilation Process

| Phase | GCC Flag | Input | Output | Purpose |
|-------|----------|-------|--------|---------|
| Preprocessing | `-E` | `program.c` | `program.i` | handle `#include`, macros |
| Compilation | `-S` | `program.i` | `program.s` | translate to assembly |
| Assembly | `-c` | `program.s` | `program.o` | assemble to machine code |
| Linking | *(none)* | `program.o` | **program** | resolve libraries, build ELF |

> **Tip:** use `gcc -Wall -g program.c -o program` during development to enable warnings and debugging symbols.

---

## 7 – Writing a Simple DNS Resolver
A DNS resolver converts a hostname into one or more IP addresses.

```c
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <hostname>\n", argv[0]);
        return 1;
    }

    struct hostent *target = gethostbyname(argv[1]);
    if (target == NULL) {
        herror("gethostbyname");
        return 2;
    }

    char ip[INET_ADDRSTRLEN];
    struct in_addr **addr_list = (struct in_addr **)target->h_addr_list;

    for (int i = 0; addr_list[i] != NULL; i++) {
        inet_ntop(AF_INET, addr_list[i], ip, sizeof ip);
        printf("IP: %s\n", ip);
    }
    return 0;
}
```
Compile with `gcc resolver.c -o resolver`.

---

## 8 – Working with Sockets
Sockets provide a generic interface to TCP/UDP networking.

```c
#include <stdio.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(void) {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) { perror("socket"); return 1; }

    struct sockaddr_in target = {
        .sin_family = AF_INET,
        .sin_port   = htons(80),
        .sin_addr   = { .s_addr = inet_addr("192.168.0.1") }
    };

    if (connect(sockfd, (struct sockaddr *)&target, sizeof target) == 0) {
        puts("Port 80 is OPEN");
    } else {
        perror("connect");
        puts("Port 80 is CLOSED");
    }

    close(sockfd);
    return 0;
}
```
Check `man 2 socket`, `man 2 connect`, `man 7 ip` whenever in doubt.

---

## 9 – Building a Basic TCP Port Scanner
```c
/*
 * Quick TCP scanner – scans ports 1‑1024
 * gcc scanner.c -o scanner
 */
#include <stdio.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <target_ip>\n", argv[0]);
        return 1;
    }

    const char *target_ip = argv[1];
    struct sockaddr_in target = { .sin_family = AF_INET };
    target.sin_addr.s_addr = inet_addr(target_ip);

    printf("Starting TCP scan against %s (ports 1‑1024)…\n", target_ip);

    for (int port = 1; port <= 1024; port++) {
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd < 0) continue;

        target.sin_port = htons(port);

        if (connect(sockfd, (struct sockaddr *)&target, sizeof target) == 0) {
            printf("Port %d OPEN\n", port);
        }
        close(sockfd);
    }
    return 0;
}
```